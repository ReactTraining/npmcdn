'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRequestHandler = createRequestHandler;
exports.createServer = createServer;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _url = require('url');

var _path = require('path');

var _fs = require('fs');

var _osTmpdir = require('os-tmpdir');

var _osTmpdir2 = _interopRequireDefault(_osTmpdir);

var _semver = require('semver');

var _createBowerPackage = require('./createBowerPackage');

var _createBowerPackage2 = _interopRequireDefault(_createBowerPackage);

var _getPackageInfo = require('./getPackageInfo');

var _getPackageInfo2 = _interopRequireDefault(_getPackageInfo);

var _getPackage = require('./getPackage');

var _getPackage2 = _interopRequireDefault(_getPackage);

var _getProperty = require('./getProperty');

var _getProperty2 = _interopRequireDefault(_getProperty);

var _ResponseUtils = require('./ResponseUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TmpDir = (0, _osTmpdir2.default)();
var URLFormat = /^\/((?:@[^\/@]+\/)?[^\/@]+)(?:@([^\/]+))?(\/.+)?$/;

function decodeParam(param) {
  return param && decodeURIComponent(param);
}

function parsePackageURL(pathname) {
  var url = (0, _url.parse)(pathname);
  var match = URLFormat.exec(url.pathname);

  if (match == null) return null;

  return { // If the URL is /@scope/name@version/path.js?bundle:
    packageName: match[1], // @scope/name
    version: decodeParam(match[2]), // version
    filename: decodeParam(match[3]), // /path.js
    search: url.search // ?bundle
  };
}

function createPackageURL(packageName, version, filename, search) {
  var pathname = '/' + packageName;

  if (version != null) pathname += '@' + version;

  if (filename != null) pathname += filename;

  if (search) pathname += search;

  return pathname;
}

var OneMinute = 60;
var OneDay = OneMinute * 60 * 24;
var OneYear = OneDay * 365;

function isVersionNumber(version) {
  return (/^\d/.test(version)
  );
}

function getMaxAge(packageVersion) {
  if (!isVersionNumber(packageVersion)) return OneMinute;

  // Since NPM package versions can't be overwritten,
  // cache this file for a very long time.
  return OneYear;
}

var ResolveExtensions = ['', '.js', '.json'];

/**
 * Resolves a path like "lib/index" into "lib/index.js" or
 * "lib/index.json" depending on which one is available, similar
 * to how require('lib/index') does.
 */
function resolveFile(file, callback) {
  ResolveExtensions.reduceRight(function (next, ext) {
    return function () {
      (0, _fs.stat)(file + ext, function (error, stat) {
        if (stat && stat.isFile()) {
          callback(null, file + ext);
        } else if (error && error.code !== 'ENOENT') {
          callback(error);
        } else {
          next();
        }
      });
    };
  }, callback)();
}

/**
 * Creates and returns a function that can be used in the "request"
 * event of a standard node HTTP server. Options are:
 *
 * - registryURL      The URL of the npm registry (optional, defaults to https://registry.npmjs.org)
 * - bowerBundle      A special pathname that is used to create and serve zip files required by Bower
 *                    (optional, defaults to "/bower.zip")
 */
function createRequestHandler() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var registryURL = options.registryURL || 'https://registry.npmjs.org';
  var bowerBundle = options.bowerBundle || '/bower.zip';

  return function handleRequest(req, res) {
    var url = parsePackageURL(req.url);

    if (url == null) return (0, _ResponseUtils.sendInvalidURLError)(res, req.url);

    var filename = url.filename;
    var packageName = url.packageName;
    var search = url.search;

    var version = url.version || 'latest';
    var tarballDir = (0, _path.join)(TmpDir, packageName + '-' + version);

    function tryToFinish() {
      if (filename === bowerBundle) {
        (0, _createBowerPackage2.default)(tarballDir, function (error, file) {
          if (error) {
            (0, _ResponseUtils.sendServerError)(res, error);
          } else if (file === null) {
            (0, _ResponseUtils.sendNotFoundError)(res, 'bower.zip in package ' + packageName + '@' + version);
          } else {
            (0, _ResponseUtils.sendFile)(res, file, getMaxAge(version));
          }
        });
      } else if (filename) {
        var file = (0, _path.join)(tarballDir, filename);

        resolveFile(file, function (error, file) {
          if (error) {
            (0, _ResponseUtils.sendServerError)(res, error);
          } else if (file == null) {
            (0, _ResponseUtils.sendNotFoundError)(res, 'file "' + filename + '" in package ' + packageName + '@' + version);
          } else {
            (0, _ResponseUtils.sendFile)(res, file, getMaxAge(version));
          }
        });
      } else {
        (0, _fs.readFile)((0, _path.join)(tarballDir, 'package.json'), 'utf8', function (error, data) {
          if (data) filename = (0, _getProperty2.default)(JSON.parse(data), req.query && req.query.main || 'main');

          if (filename == null) filename = '/index.js'; // Default main is index.js, same as npm

          tryToFinish();
        });
      }
    }

    (0, _fs.stat)((0, _path.join)(tarballDir, 'package.json'), function (error, stat) {
      if (stat && stat.isFile()) return tryToFinish(); // Best case: we already have this package on disk.

      // Fetch package info from NPM registry.
      (0, _getPackageInfo2.default)(registryURL, packageName, function (error, info) {
        if (error) {
          if (error.statusCode === 404) {
            (0, _ResponseUtils.sendNotFoundError)(res, 'package "' + packageName + '"');
          } else {
            (0, _ResponseUtils.sendServerError)(res, error);
          }

          return;
        }

        if (info == null || info.versions == null) return (0, _ResponseUtils.sendServerError)(res, new Error('Unable to retrieve info for package ' + packageName));

        var versions = info.versions;
        var tags = info['dist-tags'];


        if (version in versions) {
          // A valid request for a package we haven't downloaded yet.
          var packageConfig = versions[version];
          var tarballURL = (0, _url.parse)(packageConfig.dist.tarball);

          (0, _getPackage2.default)(tarballURL, tarballDir, function (error) {
            if (error) {
              (0, _ResponseUtils.sendServerError)(res, error);
            } else {
              tryToFinish();
            }
          });
        } else if (version in tags) {
          (0, _ResponseUtils.sendRedirect)(res, createPackageURL(packageName, tags[version], filename, search));
        } else {
          var maxVersion = (0, _semver.maxSatisfying)(Object.keys(versions), version);

          if (maxVersion) {
            (0, _ResponseUtils.sendRedirect)(res, createPackageURL(packageName, maxVersion, filename, search));
          } else {
            (0, _ResponseUtils.sendNotFoundError)(res, 'package ' + packageName + '@' + version);
          }
        }
      });
    });
  };
}

/**
 * Creates and returns an HTTP server that serves files from NPM packages.
 * Supported URL schemes are:
 *
 * /history@1.12.5/umd/History.min.js (recommended)
 * /history@1.12.5 (package.json's main is implied)
 *
 * Additionally, the following URLs are supported but will return a
 * temporary (302) redirect:
 *
 * /history (redirects to version, latest is implied)
 * /history/umd/History.min.js (redirects to version, latest is implied)
 * /history@latest/umd/History.min.js (redirects to version)
 */
function createServer(options) {
  return _http2.default.createServer(createRequestHandler(options));
}